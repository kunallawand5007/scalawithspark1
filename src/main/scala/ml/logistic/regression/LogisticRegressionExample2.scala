package ml.logistic.regression

import com.kj.spark.session.Context
import ml.logistic.regression.LogisticRegressionExample.predecationdf
import ml.logistic.regression.LogisticRegressionExample2.fileLoaded
import org.apache.spark.ml.classification.LogisticRegression
import org.apache.spark.ml.evaluation.BinaryClassificationEvaluator
import org.apache.spark.ml.feature.{StringIndexer, VectorAssembler}
import org.apache.spark.sql.types.{BooleanType, DataTypes, IntegerType, StringType}

object LogisticRegressionExample2 extends App with Context{


 var fileLoaded = sparkSession.read.format("csv").option("header", "true") ////first line in file has headers
   .option("delimiter", ";")
   .load("D:\\lockdown\\data\\student-mat.csv")
   //.select("school","sex","age","romantic")  //// now select some column
     //.toDF()








  val convertedf= fileLoaded
    .withColumn("age",fileLoaded("age").cast(IntegerType))
    .withColumn("romantic",fileLoaded("romantic").cast(BooleanType))
    .withColumn("G1",fileLoaded("G1").cast(IntegerType))
    .withColumn("G2",fileLoaded("G2").cast(IntegerType))
    .withColumn("G3",fileLoaded("G3").cast(IntegerType))
    .select("age","romantic","G1","G2","G3")
     .toDF()

  println("Show schema....")
  convertedf.printSchema()
  convertedf.show(150)






   // create vector
    val cols = Array("age","romantic","G1","G2","G3")

  //the VectorAssembler Transformer does not take strings.
  //val analysisData  = dataframe_mysql.withColumn("Event", dataframe_mysql("Event").cast(DoubleType))
  //VectorAssembler is a transformer that combines a given list of columns into a single vector column.
  // It is useful for combining raw features and features generated by different feature transformers into a single feature vector, in order to train ML models like logistic regression and decision trees.
  // VectorAssembler accepts the following input column types: all numeric types, boolean type, and vector type. In each row, the values of the input columns will be concatenated into a vector in the specified order.

   val assembler = new VectorAssembler().setInputCols(cols).setOutputCol("features")
   val featuredf =assembler.transform(convertedf)
   featuredf.printSchema()
   featuredf.show(50)


 val strtyedf=featuredf.withColumn("romantic",featuredf("romantic").cast(StringType))
 strtyedf.printSchema()

   // create label


  val stringIndexer = new StringIndexer()
    .setInputCol("romantic")  //required column of String or Numeric type
    .setOutputCol("label")

  val labeldf = stringIndexer.fit(strtyedf).transform(strtyedf)

  labeldf.printSchema()
  labeldf.show(50)

        val Array(trainingdata,testdata) = labeldf.randomSplit(Array(0.7,0.3),12345)



         val regression = new LogisticRegression().setMaxIter(100).setRegParam(0.02).setElasticNetParam(0.8)
         val regressionModel=regression.fit(trainingdata)

          val predictdf = regressionModel.transform(testdata)

            predictdf.printSchema()
            predictdf.show(500)

    // evaluate model
    val evaluator = new BinaryClassificationEvaluator().setLabelCol("label")
      .setRawPredictionCol("prediction")
      .setMetricName("areaUnderROC") //Receiver operating characteristic (ROC)

 // measure the accuracy
 val accuracy = evaluator.evaluate(predictdf)
 println(accuracy)


 println(s"train data:$trainingdata.count()")
 println(s"Test Data:${testdata.count()}")
}
